<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8">
  <title>PairHMM with WebGPU - 使用多個 Workgroups 加速 (完整修改後程式碼)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      color: white;
      font-family: monospace;
    }
    #output {
      white-space: pre-wrap;
      padding: 10px;
    }
  </style>
</head>
<body>
  <!-- 輸出結果區域 -->
  <div id="output"></div>
  <script type="module">
    // 輸出訊息函式
    function print(msg) {
      const outputDiv = document.getElementById("output");
      outputDiv.innerText += msg + "\n";
    }
  
    async function runPairHMM() {
      if (!navigator.gpu) {
        print("WebGPU 不支援");
        return;
      }
      // 請求 adapter 與 device
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
  
      // 基本常數設定
      const STATES = 3;      // 狀態：Match, Insert, Delete
      const ALPHABETS = 5;   // 可見字母數
      const LOG_ZERO = -1e30;
      const WORKGROUP_SIZE = 256;
  
      // 輔助函式：建立 shader module
      function createShaderModule(code) {
        return device.createShaderModule({ code });
      }
  
      // ---------------------------------------------------------
      // 修改 BindGroupLayout，移除動態 uniform（hasDynamicOffset）設定
      const bindGroupLayout = device.createBindGroupLayout({
        entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
          // 修改 binding 7，移除 hasDynamicOffset，並接收統一數據 (Uniforms)
          { binding: 7, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
          { binding: 8, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
        ]
      });
  
      const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      });
  
      // ---------------------------------------------------------
      // 修改 Compute Shader：改用多個 Workgroups 並根據 workgroup_id 分區計算
      const diagonalShaderCode = `
struct Uniforms {
  len: u32,
  diag: u32,
  numGroups: u32,
  padding: u32, // 填充至 16 bytes 對齊
};

@group(0) @binding(0) var<storage, read> readProbMatrix : array<f32>;
@group(0) @binding(1) var<storage, read> haplotype : array<u32>;
@group(0) @binding(2) var<storage, read> emissionMatrix : array<f32>;
@group(0) @binding(3) var<storage, read> transitionMatrix : array<f32>;

@group(0) @binding(4) var<storage, read> dp_prev : array<f32>;
@group(0) @binding(5) var<storage, read> dp_curr : array<f32>;

@group(0) @binding(6) var<storage, read_write> dAns : array<f32>;

@group(0) @binding(7) var<uniform> u : Uniforms;

@group(0) @binding(8) var<storage, read_write> dp_new : array<f32>;

fn logSum2(a: f32, b: f32) -> f32 {
  if (a == ${LOG_ZERO}) { return b; }
  if (b == ${LOG_ZERO}) { return a; }
  if (a > b) { return a + log(1.0 + exp(b - a)); }
  return b + log(1.0 + exp(a - b));
}
fn logSum3(a: f32, b: f32, c: f32) -> f32 {
  return logSum2(logSum2(a, b), c);
}

@compute @workgroup_size(${WORKGROUP_SIZE})
fn main(@builtin(workgroup_id) wg_id : vec3<u32>, @builtin(local_invocation_id) local_id : vec3<u32>) {
  let len = u.len;
  let diag = u.diag;
  let totalCells = diag + 1u;
  let groups = u.numGroups;
  let groupIndex = wg_id.x;

  // 計算本 workgroup 處理的區間 [start, end)
  let start = (totalCells * groupIndex) / groups;
  let end = (totalCells * (groupIndex + 1u)) / groups;
  
  // 每個工作項目負責處理區間中的多個位置
  for (var t: u32 = start + local_id.x; t < end; t = t + ${WORKGROUP_SIZE}u) {
    let i = diag - t;
    let j = t;
    if (i >= 1u && i <= len && j >= 1u && j <= len) {
      // 取得 haplotype 字元並轉換為對應 index
      let hap_char = haplotype[j - 1u];
      var hapIndex: u32 = 4u;
      if (hap_char == 65u) { hapIndex = 0u; }
      else if (hap_char == 67u) { hapIndex = 1u; }
      else if (hap_char == 71u) { hapIndex = 2u; }
      else if (hap_char == 84u) { hapIndex = 3u; }
  
      var logProbabilityM: f32 = ${LOG_ZERO};
      var logProbabilityI: f32 = ${LOG_ZERO};
      for (var a: u32 = 0u; a < 4u; a = a + 1u) {
        let prob = readProbMatrix[(i - 1u) * 4u + a];
        if (prob > 0.0) {
          let emiss = emissionMatrix[0u * ${ALPHABETS}u * ${ALPHABETS}u + a * ${ALPHABETS}u + hapIndex];
          let candidate = log(prob) + emiss;
          logProbabilityM = logSum2(logProbabilityM, candidate);
        }
      }
      for (var a: u32 = 0u; a < 4u; a = a + 1u) {
        let prob = readProbMatrix[(i - 1u) * 4u + a];
        if (prob > 0.0) {
          let emiss = emissionMatrix[1u * ${ALPHABETS}u * ${ALPHABETS}u + a * ${ALPHABETS}u + 4u];
          let candidate = log(prob) + emiss;
          logProbabilityI = logSum2(logProbabilityI, candidate);
        }
      }
  
      // dp_prev 與 dp_curr 中的資料依區段存放：M、I、D
      let size = len + 1u;
      let t00 = dp_prev[0u * size + (i - 1u)];
      let t10 = dp_prev[1u * size + (i - 1u)];
      let t20 = dp_prev[2u * size + (i - 1u)];
      let newM = logProbabilityM + logSum3(t00 + transitionMatrix[0],
                                             t10 + transitionMatrix[3],
                                             t20 + transitionMatrix[6]);
  
      let t01 = dp_curr[0u * size + (i - 1u)];
      let t11 = dp_curr[1u * size + (i - 1u)];
      let newI = logProbabilityI + logSum2(t01 + transitionMatrix[1],
                                            t11 + transitionMatrix[4]);
  
      let t02 = dp_curr[0u * size + i];
      let t22 = dp_curr[2u * size + i];
      let newD = logSum2(t02 + transitionMatrix[2],
                         t22 + transitionMatrix[8]);
  
      dp_new[0u * size + i] = newM;
      dp_new[1u * size + i] = newI;
      dp_new[2u * size + i] = newD;
  
      if (i == len) {
        // 本儲存格負責累加答案
        dAns[0] = logSum2(dAns[0], logSum2(newM, newI));
      }
    }
  }
}
`;
  
      const diagonalModule = createShaderModule(diagonalShaderCode);
      const diagonalPipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: { module: diagonalModule, entryPoint: "main" }
      });
  
      // ---------------------------------------------------------
      // 輔助函式：從 Array 建立 GPU Buffer（mappedAtCreation）
      function createBufferFromArray(arr, usage) {
        const buffer = device.createBuffer({
          size: arr.byteLength,
          usage: usage,
          mappedAtCreation: true,
        });
        const mapping = new Float32Array(buffer.getMappedRange());
        mapping.set(arr);
        buffer.unmap();
        return buffer;
      }
  
      // ---------------------------------------------------------
      // 建立其他所需 Buffer：readProb、haplotype、emissionMatrix、transitionMatrix
      const lengths = [100, 1000, 10000, 100000];
  
      // 輔助函式：建立 dp 初始值資料
      function createDPInitialData(len) {
        const size = len + 1;
        const total = 3 * size;
        let arr = new Float32Array(total);
        arr.fill(LOG_ZERO);
        arr[2 * size + 0] = Math.log(1.0 / len);
        return arr;
      }
      const dAnsInit = new Float32Array([LOG_ZERO]);
  
      for (let len of lengths) {
        print(`開始計算長度 ${len}`);
        const size = len + 1;
  
        // 建立 transitionMatrix (3x3)
        const transitionMatrix = new Float32Array([
          Math.log(0.9), Math.log(0.1), LOG_ZERO,
          Math.log(0.1), Math.log(0.8), Math.log(0.1),
          Math.log(0.1), LOG_ZERO, Math.log(0.9)
        ]);
  
        // 建立 emissionMatrix (3 x 5 x 5)
        const emissionMatrix = new Float32Array(STATES * ALPHABETS * ALPHABETS);
        emissionMatrix[0 * ALPHABETS * ALPHABETS + 0 * ALPHABETS + 0] = Math.log(0.9);
        emissionMatrix[0 * ALPHABETS * ALPHABETS + 1 * ALPHABETS + 1] = Math.log(0.8);
        emissionMatrix[0 * ALPHABETS * ALPHABETS + 2 * ALPHABETS + 2] = Math.log(0.9);
        emissionMatrix[0 * ALPHABETS * ALPHABETS + 3 * ALPHABETS + 3] = Math.log(0.7);
        emissionMatrix[0 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 4] = Math.log(0.1);
        emissionMatrix[1 * ALPHABETS * ALPHABETS + 0 * ALPHABETS + 4] = Math.log(0.1);
        emissionMatrix[1 * ALPHABETS * ALPHABETS + 1 * ALPHABETS + 4] = Math.log(0.1);
        emissionMatrix[1 * ALPHABETS * ALPHABETS + 2 * ALPHABETS + 4] = Math.log(0.1);
        emissionMatrix[1 * ALPHABETS * ALPHABETS + 3 * ALPHABETS + 4] = Math.log(0.1);
        emissionMatrix[1 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 4] = Math.log(0.6);
        emissionMatrix[2 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 0] = Math.log(0.2);
        emissionMatrix[2 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 1] = Math.log(0.2);
        emissionMatrix[2 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 2] = Math.log(0.2);
        emissionMatrix[2 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 3] = Math.log(0.2);
        emissionMatrix[2 * ALPHABETS * ALPHABETS + 4 * ALPHABETS + 4] = Math.log(0.2);
  
        // 建立 readProbMatrix：長度 (len x 4)，所有元素 0.25
        const readProbMatrix = new Float32Array(len * 4);
        for (let i = 0; i < len * 4; i++) {
          readProbMatrix[i] = 0.25;
        }
        // 建立 haplotype：長度 len，全部 'A' (ASCII 65)
        const haplotype = new Uint32Array(len);
        for (let i = 0; i < len; i++) {
          haplotype[i] = 65;
        }
  
        // 建立 GPU Buffer（readProbBuffer、haplotypeBuffer、emissionBuffer、transitionBuffer）
        const readProbBuffer = createBufferFromArray(readProbMatrix, GPUBufferUsage.STORAGE);
  
        const haplotypeBuffer = device.createBuffer({
          size: haplotype.byteLength,
          usage: GPUBufferUsage.STORAGE,
          mappedAtCreation: true,
        });
        new Uint32Array(haplotypeBuffer.getMappedRange()).set(haplotype);
        haplotypeBuffer.unmap();
  
        const emissionBuffer = createBufferFromArray(emissionMatrix, GPUBufferUsage.STORAGE);
        const transitionBuffer = createBufferFromArray(transitionMatrix, GPUBufferUsage.STORAGE);
  
        // ---------------------------------------------------------
        // 建立 dp 緩衝區：dp_prev, dp_curr, dp_new
        // 每個 dp 緩衝區尺寸 = 3*(len+1)*4 bytes
        const dpTotalBytes = 3 * (len + 1) * 4;
        const dpInitData = createDPInitialData(len);
        const dp_prev = createBufferFromArray(dpInitData, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        const dp_curr = createBufferFromArray(dpInitData, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        const dp_new = createBufferFromArray(dpInitData, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
  
        // 建立 dAns 緩衝區
        const dAnsBuffer = createBufferFromArray(dAnsInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
  
        // ---------------------------------------------------------
        // 定義 chunk size（例如，每個 chunk 處理 200000 條對角線 passes）
        const chunkSize = 200000;
        const totalDiag = 2 * len;
        const t0 = performance.now();
  
        // 建立一個全域 command encoder，將所有 diagonal passes 一次性記錄
        const globalEncoder = device.createCommandEncoder();
        for (let chunkStart = 1; chunkStart <= totalDiag; chunkStart += chunkSize) {
          const chunkEnd = Math.min(chunkStart + chunkSize - 1, totalDiag);
          for (let diag = chunkStart; diag <= chunkEnd; diag++) {
            // 為每一個 diagonal pass 計算適合的 Workgroup 數量：每個 Workgroup 預設最多處理 ${WORKGROUP_SIZE} 個 cell
            let totalCells = diag + 1;
            let numGroups = Math.ceil(totalCells / WORKGROUP_SIZE);
            // 建立 Uniform 資料：包含 len, diag, numGroups, 以及 padding (共 16 bytes)
            const uniformData = new Uint32Array([len, diag, numGroups, 0]);
            const uniformBuffer = device.createBuffer({
              size: 16,
              usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformData.buffer);
  
            // 為此 diagonal pass 建立 bind group
            const diagBindGroup = device.createBindGroup({
              layout: bindGroupLayout,
              entries: [
                { binding: 0, resource: { buffer: readProbBuffer } },
                { binding: 1, resource: { buffer: haplotypeBuffer } },
                { binding: 2, resource: { buffer: emissionBuffer } },
                { binding: 3, resource: { buffer: transitionBuffer } },
                { binding: 4, resource: { buffer: dp_prev } },
                { binding: 5, resource: { buffer: dp_curr } },
                { binding: 6, resource: { buffer: dAnsBuffer } },
                { binding: 7, resource: { buffer: uniformBuffer } },
                { binding: 8, resource: { buffer: dp_new } }
              ]
            });
  
            const pass = globalEncoder.beginComputePass();
            pass.setPipeline(diagonalPipeline);
            pass.setBindGroup(0, diagBindGroup);
            pass.dispatchWorkgroups(numGroups);
            pass.end();
  
            // 每次 diagonal pass 完成後複製 dp_curr → dp_prev，以及 dp_new → dp_curr
            globalEncoder.copyBufferToBuffer(dp_curr, 0, dp_prev, 0, dpTotalBytes);
            globalEncoder.copyBufferToBuffer(dp_new, 0, dp_curr, 0, dpTotalBytes);
          }
        }
        // 一次性送出全部 command encoder 指令
        device.queue.submit([globalEncoder.finish()]);
        await device.queue.onSubmittedWorkDone();
  
        const t1 = performance.now();
        const elapsed = (t1 - t0) / 1000;
  
        // ---------------------------------------------------------
        // 讀取 dAns 結果
        const resultBuffer = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });
        const encoder2 = device.createCommandEncoder();
        encoder2.copyBufferToBuffer(dAnsBuffer, 0, resultBuffer, 0, 4);
        device.queue.submit([encoder2.finish()]);
        await resultBuffer.mapAsync(GPUMapMode.READ);
        const resultArray = new Float32Array(resultBuffer.getMappedRange());
        const ans = resultArray[0];
        resultBuffer.unmap();
  
        print(`長度: ${len}, 耗時: ${elapsed.toFixed(3)} 秒, Log-Likelihood: ${ans}`);
      }
    }
    runPairHMM();
  </script>
</body>
</html>
